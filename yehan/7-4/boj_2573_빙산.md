# BOJ 2573ë²ˆ ë¹™ì‚°

[BOJ 2573ë²ˆ ë¹™ì‚°](https://www.acmicpc.net/problem/2573)

### ğŸ¤” ë¬¸ì œ ì´í•´í•˜ê¸°

1. ë¹™ì‚°ì˜ ì •ë³´ê°€ ë°°ì—´ì— ì €ì¥ëœë‹¤.
2. 1ë…„ ë™ì•ˆ ì‚¬ë°©ì— ì¸ì ‘í•œ 0ì˜ ìˆ˜ë§Œí¼ ë¹™ì‚°ì´ ë…¹ëŠ”ë‹¤.
3. ëª‡ ë…„ í›„ì— ë¹™ì‚°ì´ 2ê°œ ì´ìƒì˜ ë©ì–´ë¦¬ë¡œ ë¶„ë¦¬ë˜ëŠ”ì§€ êµ¬í•œë‹¤.

- 3 â‰¤ í–‰, ì—´ â‰¤ 300

### â­ ì•Œê³ ë¦¬ì¦˜

- bfs
  1ë…„ ë™ì•ˆ ë¹™ì‚°ì´ ë…¹ëŠ” ê²ƒìœ¼ íŒŒì•…í•˜ê¸° ìœ„í•´ bfsë¡œ íƒìƒ‰í•´ ë‚˜ê°„ë‹¤.
- dfs
  ë¹™ì‚° ë©ì–´ë¦¬ì˜ ê°œìˆ˜ë¥¼ íŒŒì•…í•˜ê¸° ìœ„í•´ dfsë¡œ íƒìƒ‰í•´ ë‚˜ê°„ë‹¤.

### ğŸ“– ìŠ¤í† ë¦¬ ë¼ì¸

1. 1ë…„ ë™ì•ˆ ë…¹ëŠ” ë¹™ì‚°ì˜ ìœ„ì¹˜ì™€ ì–‘ì„ ì €ì¥í•œë‹¤.
2. 1ë…„ í›„ <1>ì—ì„œ ì €ì¥í•´ë‘” ì •ë³´ë¥¼ í•œ ë²ˆì— ì—…ë°ì´íŠ¸í•œë‹¤.
3. dfsë¡œ ì¸ì ‘í•œ ë¹™ì‚° ë©ì–´ë“¤ì„ íƒìƒ‰í•´ ë‚˜ê°„ë‹¤.

### âš ï¸ ì£¼ì˜ ì‚¬í•­

- ìŠ¤í† ë¦¬ë¼ì¸ 2ë²ˆì„ ì£¼ì˜í•˜ì.
  íƒìƒ‰í•´ ë‚˜ê°€ë©° ë¹™ì‚°ì„ ë…¹ì¸ë‹¤ë©´ ë‹¤ë¥¸ ë¹™ì‚°ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆë‹¤.
  ```
  5 7
  0 0 0 0 0 0 0
  0 3 6 0 6 7 0
  0 3 0 0 0 10 0
  0 0 0 0 0 0 0
  0 0 0 0 0 0 0
  ì •ë‹µ) 0
  ```

### ğŸ’» ë¬¸ì œë¥¼ í•´ê²°í•œ ì½”ë“œ

```java
import java.io.*;
import java.util.*;

public class Main {

    static int n, m, map[][];
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        map = new int[n][m];
        Queue<Iceberg> q = new LinkedList<>();

        for (int i = 0; i < n; ++i) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < m; ++j) {
                map[i][j] = Integer.parseInt(st.nextToken());
                if (map[i][j] > 0) q.offer(new Iceberg(i, j, 1));
            }
        }

        sb.append(solve(q)).append("\n");

        bw.write(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }

    static class Iceberg {
        int x, y, days;

        Iceberg(int x, int y, int days) {
            this.x = x;
            this.y = y;
            this.days = days;
        }
    }

    // bfs
    // 1ë…„ë™ì•ˆ ë¬¼ê³¼ ì¸ì ‘í•œ ë¹™ì‚°ì´ ë…¹ìŒ
    static int solve(Queue<Iceberg> q) {
        Queue<Iceberg> newmap = new LinkedList<>();

        if (q.size() == 1) return 0; // ë¹™ì‚° ë©ì–´ë¦¬ê°€ ì²˜ìŒì— 1ê°œì¸ ê²½ìš°
        if (aYearPassed(newmap)) return 0; // ì‹œì‘ë¶€í„° 2ê°œ ì´ìƒì˜ ë©ì–´ë¦¬ë¡œ ë‚˜ë‰˜ì–´ì ¸ ìˆëŠ” ê²½ìš°

        while (!q.isEmpty()) {
            Iceberg cur = q.poll();
            int cx = cur.x;
            int cy = cur.y;
            int cdays = cur.days;

            // í•´ë‹¹ ë¹™ì‚°ê³¼ ì¸ì ‘í•œ ë¬¼ì˜ ê°œìˆ˜ í™•ì¸
            int water = 0;
            for (int dir = 0; dir < 4; ++dir) {
                int nx = cx + dx[dir];
                int ny = cy + dy[dir];

                if (nx < 0 || nx >=n || ny < 0 || ny >=m) continue;
                if (map[nx][ny] <= 0) water += 1;
            }
            if (water > 0) newmap.offer(new Iceberg(cx, cy, water));
            if (map[cx][cy] - water > 0) q.offer(new Iceberg(cx, cy, cdays + 1));

            // 1ë…„ì´ ì§€ë‚¬ë‹¤ë©´ ë¹™ì‚°ì´ ë¶„ë¦¬ë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (q.isEmpty()) break; // ì´ë¯¸ ë‹¤ ë…¹ì•„ë²„ë ¸ë‹¤ë©´
            if (cur.days < q.peek().days && aYearPassed(newmap)) return cdays;
        }
        return 0;
    }

    // 1ë…„ ë’¤ mapì˜ ëª¨ìŠµ
    static boolean aYearPassed(Queue<Iceberg> newmap) {
        // ë¹™ì‚°ì„ ë…¹ì´ì
        while (!newmap.isEmpty()) {
            Iceberg melt = newmap.poll();
            map[melt.x][melt.y] -= melt.days;
        }

        // 2ê°œ ì´ìƒì˜ ë©ì–´ë¦¬ë¡œ ë¶„ë¦¬ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì
        int chunk = 0;
        boolean[][] visited = new boolean[n][m];

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (visited[i][j]) continue; // ì´ë¯¸ ê²€ì‚¬í•œ ê³³ì´ë¼ë©´ ì§€ë‚˜ê°€ê¸°

                if (map[i][j] <= 0) { // ë¬¼ì¸ ê²½ìš°
                    visited[i][j] = true;
                } else { // ë¹™ì‚°ì¸ ê²½ìš°
                    chunk += 1;
                    findChunk(i, j, visited);
                }
            }
        }

        if (chunk > 1) return true;
        return false;
    }

    // dfs
    // ì—°ê²°ëœ ë¹™ì‚° ì¡°ê°ë“¤ì„ íƒìƒ‰
    static void findChunk(int x, int y, boolean[][] visited) {
        for (int dir = 0; dir < 4; ++dir) {
            visited[x][y] = true;

            int nx = x + dx[dir];
            int ny = y + dy[dir];
            if (map[nx][ny] > 0 && !visited[nx][ny]) findChunk(nx, ny, visited);
        }
    }

}
```
